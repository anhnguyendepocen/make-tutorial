---
output:
  title: A tutorial introduction to Make for reproducible research
  pdf_document:
    keep_tex: true
    toc: false
    includes:
       in_header: preamble.sty
  html_document:
    self_contained: false
    toc: true
    toc_float: false
---


```{r rsetup,eval=TRUE,include=FALSE}
require(knitr)
require(rprojroot)
require(xtable)
options(width=60)
opts_chunk$set(cache=FALSE)
```

# Introduction

Why make is useful.  Originally designed into 1970s for the efficient
compilation of programs.  Gradually adopted to other situations.


# Example problem

## Estimating pi.

how to estimate pi with a dartboard

## Traditional approach - write a batch file.

```{bash, code=readLines("v1-R/pi-workflow.sh"), echo=TRUE,eval=FALSE}
```

# Version 1 (R makefile)

```{bash, code = readLines("v1-R/Makefile"), eval=FALSE,echo=TRUE}
```

## TODO Anatomy of a rule.

what is a rule?  target? dependency?  how it does it decide whether to
re-execture the rule (timestamps of files).


## Running it (for real)


```{bash}
cd v1-R; make
```

This should generate a new pdf, `darts.pdf`.  If we then delete
darts.pdf by accident, when we run `make` again, it will not need to
run all steps of the analysis, as the intermediate files are still
present.


```{bash}
cd v1-R
rm darts.pdf
make
```


\begin{figure}
  \centering
	\includegraphics{v1-R/darts.pdf}
  \caption{Example output file, darts.pdf, created by "make" command.
  Blue (or red) points are those that were determined to be inside (or
  outside) the circle.  The estimate of pi, given in the title, was
  then given as 4*d/n, where d is the number of darts inside the
  circle and n is the total number of darts thrown.}
  \label{fig:darts}
\end{figure}


## DAG

One nice thing about using a Makefile is usually you can visualize the
dependency graph.  e.g.  Figure 2.  Input files are clearly shown in
green, and everything else in red can be regenerated.


\begin{figure}
  \centering
	\includegraphics{v1-R/graph.pdf}
  \caption{DAG for Makefile version 1.}
  \label{fig:dag}
\end{figure}



(This figure is generated by analysing the structure of the output
from the make program, thanks to a program from \url{}

## Explain what PHONY targets are.

Two common PHONY targets are the "all" and "clean" targets.  "make
all" by convention is a request to regenerate all the files in the
directory, rather than to generate a file called "all".  Likewise,
"clean" is a convention to remove all the files that can be deleted.




\clearpage

# Version 2 -- generate lots of simulations.

In version 2, we want to highlight how to make rules more flexible.
Example application here would be generating lots of simulation runs,
rather than just one.



## Version 2 (R Makefile2)

```{bash, code = readLines("v1-R/Makefile2"), eval=FALSE,echo=TRUE}
```

Try to generate B=15 samples, and then show a histogram of the
distribution of the B estimates of pi.


```{bash}
cd v1-R
make -f Makefile2
cat pi-*est
```

Describe `make -j8` to run this in parallel.


NOTE: intermediate files are not kept.  

Perhaps show a 4x3 grid of 12 simulations?

# What next

Further reading (books); other programs that build upon idea of make
(snakemake, drake).

\url{https://www.frontiersin.org/articles/10.3389/fninf.2016.00002/full}


# Notes

Is it worth having this in Rmarkdown, or would a Rnw be better, so
that we can just work with latex?

# Acknowledgements

Mozilla CODECHECK for funding
